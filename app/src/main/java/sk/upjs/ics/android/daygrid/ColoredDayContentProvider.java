package sk.upjs.ics.android.daygrid;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Color;
import android.net.Uri;
import android.util.Log;
import android.util.MonthDisplayHelper;

import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults;

import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.ALL_COLUMNS;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.AUTOGENERATED_ID;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.BEFORE_FIRST;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_GROUP_BY;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_HAVING;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_NULL_COLUMN_HACK;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_SELECTION;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_SELECTION_ARGS;
import static sk.upjs.ics.android.daygrid.sk.upjs.ics.android.util.Defaults.NO_SORT_ORDER;

public class ColoredDayContentProvider extends ContentProvider {
    public static final String AUTHORITY = "sk.upjs.ics.android.daygrid.ColoredDayContentProvider";

    public static final String TABLE_NAME = "coloredday";

    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + TABLE_NAME);

    private static final String MIME_TYPE_COLORED_DAYS = ContentResolver.CURSOR_ITEM_BASE_TYPE + "/vnd." + AUTHORITY + "." + TABLE_NAME;

    private static final int WEEK_COUNT = 6;
    private static final int DAY_COUNT = 7;

    public static final int URI_MATCH_DAY = 0;
    public static final int URI_MATCH_MONTH = 1;

    private UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    private static final String[] COLUMN_NAMES = {
            Database.ColoredDay._ID,
            Database.ColoredDay.YEAR,
            Database.ColoredDay.MONTH,
            Database.ColoredDay.DAY,
            Database.ColoredDay.COLOR
    };

    private DatabaseOpenHelper databaseOpenHelper;

    @Override
    public boolean onCreate() {
        uriMatcher.addURI(AUTHORITY, TABLE_NAME + "/#/#/#", URI_MATCH_DAY);
        uriMatcher.addURI(AUTHORITY, TABLE_NAME + "/#/#", URI_MATCH_MONTH);

        databaseOpenHelper = new DatabaseOpenHelper(getContext());

        return true;
    }

    private SQLiteDatabase getDatabase() {
        return databaseOpenHelper.getWritableDatabase();
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
                        String[] selectionArgs, String sortOrder) {
        switch(uriMatcher.match(uri)) {
            case URI_MATCH_MONTH:
                List<String> pathSegments = uri.getPathSegments();
                int year = Integer.parseInt(pathSegments.get(1));
                int month = Integer.parseInt(pathSegments.get(2));

                Cursor cursor = getColoringsCursor(year, month);
                cursor.setNotificationUri(getContext().getContentResolver(), uri);

                return cursor;
            default:
                return null;
        }
    }

    private Cursor getColoringsCursor(int year, int month) {
        MatrixCursor matrixCursor = new MatrixCursor(COLUMN_NAMES);

        MonthDisplayHelper monthDisplayHelper = new MonthDisplayHelper(year, month - 1, Calendar.MONDAY);

        Cursor coloringsCursor = getColoringsCursor();

        for (int weekIndex = 0; weekIndex < WEEK_COUNT; weekIndex++) {
            for(int dayIndex = 0; dayIndex < DAY_COUNT; dayIndex++) {
                int day = monthDisplayHelper.getDayAt(weekIndex, dayIndex);
                int id = (weekIndex * DAY_COUNT) + dayIndex;
                if(monthDisplayHelper.isWithinCurrentMonth(weekIndex, dayIndex)) {
                    matrixCursor.addRow(toArray(id, getDayColor(coloringsCursor, year, month, day)));
                } else {
                    matrixCursor.addRow(toArray(id, ColoredDay.EMPTY));
                }
            }
        }
        coloringsCursor.close();

        return matrixCursor;
    }

    private Cursor getColoringsCursor() {
        return getDatabase()
                .query(TABLE_NAME, ALL_COLUMNS, NO_SELECTION, NO_SELECTION_ARGS, NO_GROUP_BY, NO_HAVING, NO_SORT_ORDER);
    }

    private ColoredDay getDayColor(Cursor coloringsCursor, int year, int month, int day) {
        ColoredDay coloredDay = new ColoredDay(year, month, day);
        while(coloringsCursor.moveToNext()) {
            int cursorDay = coloringsCursor.getInt(coloringsCursor.getColumnIndex(Database.ColoredDay.DAY));
            int cursorMonth = coloringsCursor.getInt(coloringsCursor.getColumnIndex(Database.ColoredDay.MONTH));
            int cursorYear = coloringsCursor.getInt(coloringsCursor.getColumnIndex(Database.ColoredDay.YEAR));
            int cursorColor = coloringsCursor.getInt(coloringsCursor.getColumnIndex(Database.ColoredDay.COLOR));

            if (cursorDay == day && cursorMonth == month && cursorYear == year) {
                coloredDay = new ColoredDay(year, month, day, cursorColor);
            }
        }
        coloringsCursor.moveToPosition(BEFORE_FIRST);
        return coloredDay;
    }

    public Object[] toArray(int id, ColoredDay coloredDay) {
        int year = coloredDay.getYear();
        int month = coloredDay.getMonth();
        int day = coloredDay.getDay();

        return new Object[] { id, year, month, day, coloredDay.getColor()} ;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public String getType(Uri uri) {
        return MIME_TYPE_COLORED_DAYS;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        switch (uriMatcher.match(uri)) {
            case URI_MATCH_DAY:
                List<String> pathSegments = uri.getPathSegments();
                int year = Integer.parseInt(pathSegments.get(1));
                int month = Integer.parseInt(pathSegments.get(2));
                int day = Integer.parseInt(pathSegments.get(3));

                int color = values.getAsInteger(Database.ColoredDay.COLOR);

                ContentValues newValues = new ContentValues();
                newValues.put(Database.ColoredDay._ID, AUTOGENERATED_ID);
                newValues.put(Database.ColoredDay.YEAR, year);
                newValues.put(Database.ColoredDay.MONTH, month);
                newValues.put(Database.ColoredDay.DAY, day);
                newValues.put(Database.ColoredDay.COLOR, color);

                getDatabase().insert(TABLE_NAME, NO_NULL_COLUMN_HACK, newValues);

                Uri monthUri = CONTENT_URI.buildUpon()
                        .appendPath(String.valueOf(year))
                        .appendPath(String.valueOf(month))
                        .build();

                getContext().getContentResolver().notifyChange(monthUri, null, false);

                return uri;
            default: return null;
        }
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
                      String[] selectionArgs) {
        throw new UnsupportedOperationException("Not yet implemented");
    }
}


